# ==========================================
# Azure App Service Deployment - Backend API
# ==========================================
# Deploys Next.js + Prisma backend to Azure App Service
# Triggered on: push to main branch
#
# Prerequisites:
# 1. Azure App Service created (firbox-api)
# 2. Publish Profile downloaded from Azure Portal
# 3. GitHub Secrets configured:
#    - AZURE_PUBLISH_PROFILE: Content of .PublishSettings file
#    - DATABASE_URL: PostgreSQL connection string (for Prisma generate)
#
# App Configuration:
# - Name: firbox-api
# - Runtime: Node.js 20 LTS
# - Framework: Next.js 15
# - Database: PostgreSQL (Neon)
# ==========================================

name: Deploy Azure Web App (firbox-api)

# ==========================================
# TRIGGER
# ==========================================
# Runs when code is pushed to main branch
on:
  push:
    branches:
      - main

  # Allow manual trigger from GitHub Actions tab
  workflow_dispatch:

# ==========================================
# ENVIRONMENT VARIABLES
# ==========================================
env:
  AZURE_WEBAPP_NAME: firbox-api           # Azure App Service name
  AZURE_WEBAPP_PACKAGE_PATH: '.'          # Path to app (root directory)
  NODE_VERSION: '20.x'                    # Node.js version

# ==========================================
# JOBS
# ==========================================
jobs:
  build-and-deploy:
    name: Build and Deploy to Azure
    runs-on: ubuntu-latest

    steps:
      # ----------------------------------------
      # Step 1: Checkout Code
      # ----------------------------------------
      # Downloads repository code to runner
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for potential versioning

      # ----------------------------------------
      # Step 2: Setup Node.js
      # ----------------------------------------
      # Configures Node.js environment
      - name: ğŸ”§ Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          # cache: 'npm'  # Disabled - package-lock.json not tracked

      # ----------------------------------------
      # Step 3: Export DATABASE_URL
      # ----------------------------------------
      # Export DATABASE_URL to $GITHUB_ENV so all subsequent steps can access it
      # This ensures Prisma Client can connect during build-time operations
      - name: ğŸ”‘ Export DATABASE_URL for pipeline
        run: |
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV
          echo "âœ… DATABASE_URL exported to pipeline environment"

      # ----------------------------------------
      # Step 4: Install Dependencies
      # ----------------------------------------
      # Installs all npm packages including dev dependencies
      # (needed for build tools, TypeScript, Prisma CLI, etc.)
      # Uses --legacy-peer-deps to handle Storybook version conflicts
      - name: ğŸ“¦ Install dependencies
        run: npm install --include=dev --legacy-peer-deps

      # ----------------------------------------
      # Step 5: Generate Prisma Client
      # ----------------------------------------
      # Generates Prisma Client for database access
      # Uses DATABASE_URL from $GITHUB_ENV (set in Step 3)
      # NOTE: We only generate, NOT migrate (migration handled separately)
      - name: ğŸ—„ï¸ Generate Prisma Client
        run: |
          echo "ğŸ” Verifying DATABASE_URL is set..."
          if [ -z "$DATABASE_URL" ]; then
            echo "âŒ ERROR: DATABASE_URL is not set!"
            echo "Please add DATABASE_URL to GitHub Secrets"
            exit 1
          fi
          echo "âœ… DATABASE_URL is set (length: ${#DATABASE_URL} chars)"

          echo "ğŸ—„ï¸ Generating Prisma Client..."
          npx prisma generate

      # ----------------------------------------
      # Step 6: Build Application
      # ----------------------------------------
      # Runs Next.js production build
      # Creates optimized .next directory
      # DATABASE_URL available from $GITHUB_ENV (set in Step 3)
      # IMPORTANT: Build BEFORE pruning dev deps (needs tailwindcss, postcss, etc.)
      - name: ğŸ—ï¸ Build Next.js application
        env:
          NODE_ENV: production
        run: |
          echo "ğŸ” Verifying DATABASE_URL for build..."
          if [ -z "$DATABASE_URL" ]; then
            echo "âŒ ERROR: DATABASE_URL is not set for build!"
            exit 1
          fi
          echo "âœ… DATABASE_URL verified (length: ${#DATABASE_URL} chars)"

          echo "ğŸ—ï¸ Building Next.js application..."
          npm run build

      # ----------------------------------------
      # Step 7: Optimize Dependencies
      # ----------------------------------------
      # Remove ONLY safe files, keep all JS files intact
      - name: ğŸ§¹ Safe optimization of node_modules
        run: |
          echo "ğŸ§¹ Starting safe node_modules optimization..."

          # Remove dev dependencies
          npm prune --omit=dev --legacy-peer-deps

          # Remove ONLY documentation and test files - DO NOT remove JS/TS files
          echo "ğŸ—‘ï¸ Removing only safe files from node_modules..."

          # Remove documentation files only
          find node_modules -type f -name "*.md" -delete
          find node_modules -type f -name "LICENSE*" -delete
          find node_modules -type f -name "CHANGELOG*" -delete
          find node_modules -type f -name "README*" -delete

          # Remove config files that are not needed at runtime
          find node_modules -type f -name ".npmignore" -delete
          find node_modules -type f -name ".gitignore" -delete
          find node_modules -type f -name ".eslintrc*" -delete
          find node_modules -type f -name ".prettierrc*" -delete

          # Remove test directories (but be careful with Next.js)
          find node_modules -type d -name "__tests__" ! -path "*/next/*" -exec rm -rf {} + 2>/dev/null || true
          find node_modules -type d -name "test" ! -path "*/next/*" -exec rm -rf {} + 2>/dev/null || true
          find node_modules -type d -name ".github" -exec rm -rf {} + 2>/dev/null || true

          # DO NOT DELETE: *.js, *.json, *.node, *.wasm files - they are needed!

          echo "ğŸ“Š Safely optimized node_modules size:"
          du -sh node_modules/

          # Verify Next.js is intact
          echo "ğŸ” Verifying Next.js installation..."
          ls -la node_modules/.bin/next || echo "âš ï¸ Next.js binary missing!"
          ls -la node_modules/next/dist/server/require-hook.js || echo "âš ï¸ require-hook missing!"

      # ----------------------------------------
      # Step 8: Prepare Deployment Package
      # ----------------------------------------
      # Creates deployment package WITH heavily optimized node_modules
      - name: ğŸ“¦ Create deployment package
        run: |
          echo "ğŸ“‹ Creating optimized deployment package..."

          # Create deployment directory
          mkdir -p deployment

          # Copy essential files
          echo "ğŸ“¦ Copying package files..."
          cp package.json deployment/
          cp next.config.js deployment/ || echo "âš ï¸ next.config.js not found"
          cp tsconfig.json deployment/ || echo "âš ï¸ tsconfig.json not found"

          # Copy source code
          echo "ğŸ“¦ Copying source code..."
          cp -r src deployment/

          # Copy built application
          echo "ğŸ“¦ Copying .next build output..."
          cp -r .next deployment/

          # Copy Prisma schema
          echo "ğŸ“¦ Copying Prisma schema..."
          mkdir -p deployment/prisma
          cp prisma/schema.prisma deployment/prisma/

          # Copy public assets (if exists)
          if [ -d "public" ]; then
            echo "ğŸ“¦ Copying public assets..."
            cp -r public deployment/
          fi

          # Copy optimized node_modules
          echo "ğŸ“¦ Copying optimized node_modules..."
          cp -r node_modules deployment/

          echo "âœ… Deployment package created"
          echo "ğŸ“Š Final package size:"
          du -sh deployment/
          echo "ğŸ“Š Breakdown by folder:"
          du -sh deployment/* | sort -h

      # ----------------------------------------
      # Step 9: Create Deployment Archive
      # ----------------------------------------
      # Zips the deployment package for upload
      - name: ğŸ“¦ Zip deployment package
        run: |
          cd deployment
          zip -r ../deployment.zip . -q
          cd ..

          echo "ğŸ“Š Package size:"
          ls -lh deployment.zip

      # ----------------------------------------
      # Step 10: Deploy to Azure App Service
      # ----------------------------------------
      # Uploads and deploys the package to Azure
      # Uses Publish Profile from GitHub Secrets
      - name: ğŸš€ Deploy to Azure App Service
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_PUBLISH_PROFILE }}
          package: deployment.zip

      # ----------------------------------------
      # Step 11: Verify Deployment
      # ----------------------------------------
      # Checks if the deployed app is responding
      - name: âœ… Verify deployment
        run: |
          echo "ğŸ” Azure Oryx is installing dependencies..."
          echo "â±ï¸ This may take 3-5 minutes on first deployment"
          sleep 120  # Give Azure Oryx time to install dependencies

          echo "ğŸ§ª Testing health endpoint..."
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/api/health || echo "000")

          if [ "$RESPONSE" = "200" ]; then
            echo "âœ… Deployment successful! Health check passed."
            echo "ğŸŒ App URL: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          else
            echo "âš ï¸ Health check returned HTTP $RESPONSE"
            echo "ğŸ” Azure Oryx may still be building. Check Azure logs."
            echo "ğŸ“ Portal: https://portal.azure.com"

            # Try again after more waiting
            echo "â±ï¸ Waiting additional 60 seconds..."
            sleep 60
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/api/health || echo "000")
            echo "ğŸ” Retry health check: HTTP $RESPONSE"
          fi

      # ----------------------------------------
      # Step 12: Cleanup
      # ----------------------------------------
      # Removes temporary files
      - name: ğŸ§¹ Cleanup
        if: always()
        run: |
          rm -rf deployment
          rm -f deployment.zip
          echo "âœ… Cleanup completed"

# ==========================================
# DEPLOYMENT NOTES
# ==========================================
#
# Environment Variables in Azure:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# These should be configured in Azure Portal:
# â†’ App Service â†’ Configuration â†’ Application Settings
#
# Required:
#   - DATABASE_URL: PostgreSQL connection string
#   - AUTH_SECRET: JWT secret (64+ chars)
#   - OPENAI_API_KEY: OpenAI API key
#   - UPSTASH_REDIS_REST_URL: Redis URL
#   - UPSTASH_REDIS_REST_TOKEN: Redis token
#   - NODE_ENV: production
#   - WEBSITE_NODE_DEFAULT_VERSION: 20-lts
#
# Optional:
#   - SMTP_HOST, SMTP_USER, SMTP_PASS: Email
#   - SENTRY_DSN: Error tracking
#   - R2_* or AZURE_STORAGE_*: File storage
#   - PAYOS_*: Payment gateway
#
# Startup Command:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Set in Azure Portal â†’ Configuration â†’ General Settings
# â†’ Startup Command: npm start
#
# OR in package.json scripts:
#   "start": "next start -p $PORT"
#
# Azure will automatically set PORT environment variable.
#
# Post-Deployment:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1. Verify app is running:
#    https://firbox-api.azurewebsites.net/api/health
#
# 2. Check logs (if issues):
#    â†’ Azure Portal â†’ App Service â†’ Log stream
#    â†’ OR: az webapp log tail --name firbox-api --resource-group firbox-rg
#
# 3. Monitor:
#    â†’ Azure Portal â†’ App Service â†’ Metrics
#    â†’ Application Insights (if configured)
#
# Database Migrations:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# This workflow does NOT run migrations automatically.
# Run migrations manually when needed:
#
# Option 1: Azure CLI
#   az webapp ssh --name firbox-api --resource-group firbox-rg
#   cd site/wwwroot
#   npx prisma migrate deploy
#
# Option 2: Local with production DB
#   DATABASE_URL="postgresql://..." npx prisma migrate deploy
#
# Option 3: Separate migration workflow
#   Create .github/workflows/migrate.yml for manual trigger
#
# Troubleshooting:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Issue: Deployment succeeds but app doesn't start
# â†’ Check: Azure Portal â†’ App Service â†’ Log stream
# â†’ Check: Startup command is set correctly
# â†’ Verify: All required env vars are set
#
# Issue: "Module not found" errors
# â†’ Check: node_modules included in deployment.zip
# â†’ Verify: npm ci ran successfully in deployment step
#
# Issue: Prisma Client errors
# â†’ Check: DATABASE_URL is set in Azure
# â†’ Verify: Prisma Client was generated during build
# â†’ Check: @prisma/client version matches prisma CLI
#
# Issue: Build takes too long
# â†’ Enable GitHub Actions cache (already enabled)
# â†’ Consider using npm ci instead of npm install
# â†’ Review dependencies for optimization
#
# ==========================================
